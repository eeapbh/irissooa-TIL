# Algorithm

## SWEA_1220 Magnetic

- 빨강->파랑을 만나면 교착상태!(1->2를 만나면 교착!)

- 구글링..참고ㅠ 머리가 안돌아간당...큰일났다...

```python
#1은 N극 성향(내려감), 2는 S극 성향(올라옴)
for tc in range(1,11):
    #NXN배열
    N = int(input())
    arr = [list(map(int,input().split())) for _ in range(N)]
    # 한 열이 같을 때 행이 움직여야됨
    cnt = 0 #교착상태 개수
    for j in range(N):
        check = 0 # 여기에 1을 만났을 때 표시해주고 확인
        for i in range(N):
            if arr[i][j] == 0:
                continue #0이면 지나감
            elif check == 0 and arr[i][j] == 2: #그전에 1이 없는데 2를 만났다면? 지나감!
                continue
            elif check == 1 and arr[i][j] == 2: # 그전에 1이 있는데 2를 만났다면 교착상태 +=1
                cnt += 1
                check = 0 #그전에 1표시 리셋
            elif arr[i][j] == 1:
                check = 1 #1을 만났다고 표시
    print('#{} {}'.format(tc, cnt))

```

- 이렇게 풀어보려고 했는데 교착상태에서 막힘...ㅠ낼 물어봐야지..

```python
#현우
for tc in range(1,11):
    N = int(input())
    board = [list(map(int,input().split())) for i in range(N)]
    # 1: N극
    # 2: S극
    # 위가 N극 아래가 S극
    #print(N,board)
    ans = 0
    for j in range(N):
        stack = []
        # 스택 왼쪽 : N극, 오른쪽: S극
        for i in range(N):
            if board[i][j] != 0:
                stack.append(board[i][j])
        # 오른쪽 바닥으로 떨어지는 넘들 처리
        while stack[-1] == 1:
            stack.pop()
        # 왼쪽 바닥으로 떨어지는 넘들 처리
        while stack[0] == 2:
            stack.pop(0)
        # 교착 상태 확인
        while stack:
 
            magnet = stack.pop()
            opp_magnet = -1
            if magnet == 1:
                opp_magnet = 2
            else:
                opp_magnet = 1
            # 같은 극인애 다 팝함
            while stack:
                if stack[-1] == magnet:
                    stack.pop()
                else:
                    break
            # 다른 극인애 다 팝함
            while stack:
                if stack[-1] == opp_magnet:
                    stack.pop()
                else:
                    break
            # 교착상태 한개 체크
            ans += 1
    print('#{} {}'.format(tc,ans))
```

- 다들 똑똑하게 잘풀었다...👍

```python
#성준
for tc in range(1, 11):
    N = int(input())
     
    cnt = 0
    nums = []
    for _ in range(N):
        nums.append(list(map(int, input().split())))
     
    for i in range(N):
        res = []
        for j in range(N):
  			#0을 포함하지 않고 append를 함
            if nums[j][i] != 0:
                res.append(nums[j][i])
         #1,2만 담은 리스트에 2씩 잘라서 볼건데 만약 1,2면 들어있으면 교착상태+=1
        for k in range(len(res)):
            if res[k:k+2] == [1, 2]:
                cnt += 1
    print('#{} {}'.format(tc, cnt))  
```

- 

```python
def DFS(i,j):
    global count
 	#종료조건, 마지막행에 도착하면 끝
    if i == 99:
        return count
 
    else:
        #행 1칸씩 아래로 내려감
        ni = i + 1
        nj = j
 		
        if arr[ni][nj] == 2:
            count += 1
            return count
        elif arr[ni][nj] ==1:
            return count
        elif arr[ni][nj] == 0:
            DFS(ni,nj)
 
for T in range(1, 11):
    N = int(input())
 
    arr = [list(map(int, input().split())) for _ in range(N)]
 
    count = 0
 
    for i in range(N):
        for j in range(N):
            if arr[i][j] == 1:
                DFS(i,j)
 
    print("#{} {}".format(T, count))
```

- 선생님 풀이

```python

#선생님 풀이
for tc in range(1,11):
    N = int(input())
    arr = [input().split() for _ in range(N)]

    ans = 0
    for i in range(N):
        #내가 만나야될 컬러
        state = 1
        for j in range(N):
            #내가 빨강을 만나야하고 마친 내자리가 빨강이라면
            if state == 1 and arr[j][i] == '1':
                state = 2
            #내가 파랑을 만나야하고 마침 내자리가 파랑이라면 교착상태 1증가
            elif state == 2 and arr[j][i] == '2':
                state = 1
                ans += 1
    print('#{} {}'.format(tc,ans))
```







## 계산기3

- 

```python

#선생님 풀이
priority = {'*':2,'/':2,'+':1,'-':1,'(':0}

for tc in range(1,11):
    input()
    line = input()
    ans = ''
    #스택준비
    stack = []

    for i in range(len(line)):
        #괄호라면
        if line[i]=='(' or line[i]==')':
            #여는 괄호는 우선순위가 제일 높으므로 무조건 삽입
            if line[i]=='(':
                stack.append(line[i])
            else:
                #여는괄호가 나올때까지 무조건 pop
                while stack[-1] != '(':
                    ans += stack.pop()
                #여는 괄호하나 버리기
                stack.pop()
        elif line[i].isdigit():
            ans += line[i]
        #연산자일떼
        else:
            if len(stack)==0:
                stack.append(line[i])
            else:
                #연산자 우선순위를 비교해서
                #스택에 탑에 있는 연산자가 현재 토큰의 우선순위보다 높거나 같다면
                while priority[stack[-1]] >= priority[line[i]]:
                    ans += stack.pop()
                    if len(stack) == 0:
                        break
                stack.append(line[i])
    #남아있는 스택 비우기
    while len(stack) > 0:
        ans += stack.pop()
###################### 중위표기식->후위표기식으로 바꿨다

    for i in ans:
        if i.isdigit():
            stack.append(int(i))
        #연산자이면 꺼내서 연산 후 다시 삽입
        else:
            B = stack.pop()
            A = stack.pop()
            if i == '+':
                stack.append(A+B)
            elif i == '-':
                stack.append(A-B)
            elif i == '*':
                stack.append(A*B)
            elif i == '/':
                stack.append(A/B)
    print('#{} {}'.format(tc,stack.pop()))
```



## BFS

```python
def BFS(a):
    queue = []
    #시작점을 넣는다.
    queue.append(a)
    visited[a] = 1 #시작점 방문 체크
    
    while len(queue) > 0:
        #큐는 선입선출, 제일 앞 정점을 뽑음
        curr = queue.pop(0)
        print(curr,end=' ')
        #해당 정점의 인접리스트를 볼거야
        for i in adj_list[curr]:
            #그 정점을 방문하지않았다면
            if not visited[i]:
                # 큐에 append하고 방문표시
                queue.append(i)
                visited[i] = 1
                
V,E = map(int,input().split())
#인접리스트
adj_list = [[] for _ in range(V+1)]
#간선수만큼 시작점, 끝점 이어진 것 표시
for i in range(E):
    st, ed = map(int,input().split())
    sdj_list[st].append(ed)
    adj_list[ed].append(st)
visited = [0] * (V+1)
BFS(1)

```

